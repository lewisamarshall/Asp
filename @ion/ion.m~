classdef ion < handle
% A class for ions dissolved in solution. 
    
    properties
        name;
        z=0;
        pKa;
        fi_mobility;
    end
    
    methods
        
        function obj=ion(name, z, pKa, fi_mobility)
            %initialize
            if(nargin ==4 )
                if ischar(name)
                    obj.name=name;
                else
                    error('Ion name must be a string.')
                end
                
                if z==int8(z) && isvector(z)
                    obj.z=int8(z);
                else
                    error('Charge states must be a vector of integers.')
                end
                
                if isvector(pKa) && length(obj.z)==length(pKa)
                    obj.pKa=single(pKa);
                else
                    error ('pKa vector must be the same size as charge vector.')
                end
                
                if isvector(fi_mobility) && length(obj.z)==length(fi_mobility)
                    obj.fi_mobility=fi_mobility;
                else
                    error ('Fully ionized mobility vector must be the same size as charge vector.')
                end
                
                if sign(obj.z)~=sign(obj.fi_mobility)
                    obj.fi_mobility=abs(obj.fi_mobility).*sign(obj.z);
                    warning('Forcing fully ionized mobility signs to match charge signs.')
                end
                
            else
                error ('Not enough inputs to describe an ion.')
            end
            
            %sort states by z
            obj=obj.z_sort();
            
        end
        
        function L=get_L(obj)
            L=zeros(size(obj.pKa));
            Ka=10.^(-obj.pKa);
            for i = 1:length(L)
                if obj.z(i)<0
                    L(i)=prod(Ka(obj.z>=obj.z(i) & obj.z<0));
                else
                    L(i)=prod(Ka(obj.z<=obj.z(i) & obj.z>=0).^(-1));
                end
            end
        end
        
        function i_frac=ionization_fraction(obj, pH)
        %This function takes the ion and the pH and computes the fraction of
        %ion in each of the ionization z states. This function does not currently
        %account for ionic strength effects. 
            L=get_L(obj);
            cH=10.^(-pH)';
            
            i_frac_denom=1+sum(L.*bsxfun(@power, cH, obj.z),2);
            
            i_frac=L.*bsxfun(@power, cH, obj.z)./i_frac_denom;  
        end
        
        function m_cond=molar_conductivity(obj, pH)
            %This function takes the ion and the pH and computes the molar
            %conductivity of each of the ionization z states. This
            %function does not currently account for ionic strength
            %effects.
            
            i_frac=ionization_fraction(obj, pH);
            
            m_cond=F*obj.z.*i_frac.*obj.fi_mobility;
            
        end
        
        function eff_mobility=effective_mobility(obj, pH)
        %This function takes the ion and a pH. It calls the ionization
        %fraction function and uses this information to compute the
        %effective mobility of the ion. This function does not currently
        %account for ionic strength effects. 
            i_frac=ionization_fraction(obj, pH);
            eff_mobility=sum(i_frac.*obj.fi_mobility.*sign(obj.z));
        end
        
        function obj=add_state(obj, new_z, new_pKa, new_fi_mobility)
            obj.z=[obj.z, new_z];
            obj.pKa=[obj.pKa, new_pKa];
            obj.fi_mobility=[obj.fi_mobility, new_fi_mobility];
            obj=obj.z_sort();
        end
        
        function obj=z_sort(obj)
          	[obj.z,Index]=sort(obj.z);
         	obj.pKa=obj.pKa(Index);
            obj.fi_mobility=obj.fi_mobility(Index);
        end
    end
    
end